{-# OPTIONS_GHC -w #-}
{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
module Frontend.Parser.AbsLatte (Tree(..), Program, TopDef, MemberDef, FdItem, Arg, FnDef, ClsDef, Block, Stmt, Item, Type, Expr, LVal, Op, Ident, johnMajorEq, module Frontend.Parser.ComposOp) where

import Frontend.Parser.ComposOp

import Data.Monoid (mappend)


-- Haskell module generated by the BNF converter

data Tag = Program_ | TopDef_ | MemberDef_ | FdItem_ | Arg_ | FnDef_ | ClsDef_ | Block_ | Stmt_ | Item_ | Type_ | Expr_ | LVal_ | Op_ | Ident_
type Program = Tree Program_
type TopDef = Tree TopDef_
type MemberDef = Tree MemberDef_
type FdItem = Tree FdItem_
type Arg = Tree Arg_
type FnDef = Tree FnDef_
type ClsDef = Tree ClsDef_
type Block = Tree Block_
type Stmt = Tree Stmt_
type Item = Tree Item_
type Type = Tree Type_
type Expr = Tree Expr_
type LVal = Tree LVal_
type Op = Tree Op_
type Ident = Tree Ident_

data Tree :: Tag -> * where
    Program :: [TopDef] -> Tree Program_
    FnTopDef :: FnDef -> Tree TopDef_
    ClsTopDef :: ClsDef -> Tree TopDef_
    MetDef :: FnDef -> Tree MemberDef_
    FieldDef :: Type -> [FdItem] -> Tree MemberDef_
    FdNoInit :: Ident -> Tree FdItem_
    Arg :: Type -> Ident -> Tree Arg_
    FnDef :: Type -> Ident -> [Arg] -> Block -> Tree FnDef_
    ClsDef :: Ident -> [MemberDef] -> Tree ClsDef_
    ClsDefEx :: Ident -> Ident -> [MemberDef] -> Tree ClsDef_
    Block :: [Stmt] -> Tree Block_
    Empty :: Tree Stmt_
    BStmt :: Block -> Tree Stmt_
    Decl :: Type -> [Item] -> Tree Stmt_
    Ass :: LVal -> Expr -> Tree Stmt_
    Incr :: LVal -> Tree Stmt_
    Decr :: LVal -> Tree Stmt_
    Ret :: Expr -> Tree Stmt_
    VRet :: Tree Stmt_
    Cond :: Expr -> Stmt -> Tree Stmt_
    CondElse :: Expr -> Stmt -> Stmt -> Tree Stmt_
    While :: Expr -> Stmt -> Tree Stmt_
    For :: Type -> Ident -> Expr -> Stmt -> Tree Stmt_
    SExp :: Expr -> Tree Stmt_
    NoInit :: Ident -> Tree Item_
    Init :: Ident -> Expr -> Tree Item_
    IntT :: Tree Type_
    StringT :: Tree Type_
    BooleanT :: Tree Type_
    VoidT :: Tree Type_
    ClassT :: Ident -> Tree Type_
    ArrayT :: Type -> Tree Type_
    FunT :: Type -> [Type] -> Tree Type_
    ELitInt :: Integer -> Tree Expr_
    ELitTrue :: Tree Expr_
    ELitFalse :: Tree Expr_
    ELitNull :: Type -> Tree Expr_
    EString :: String -> Tree Expr_
    EApp :: Ident -> [Expr] -> Tree Expr_
    ClsApply :: Expr -> Ident -> [Expr] -> Tree Expr_
    TClsApply :: Type -> Expr -> Ident -> [Expr] -> Tree Expr_
    ELVal :: LVal -> Tree Expr_
    ArrAlloc :: Type -> Expr -> Tree Expr_
    ClsAlloc :: Ident -> Tree Expr_
    Neg :: Expr -> Tree Expr_
    Not :: Expr -> Tree Expr_
    EMul :: Expr -> Op -> Expr -> Tree Expr_
    EAdd :: Expr -> Op -> Expr -> Tree Expr_
    ERel :: Expr -> Op -> Expr -> Tree Expr_
    EAnd :: Expr -> Op -> Expr -> Tree Expr_
    EOr :: Expr -> Op -> Expr -> Tree Expr_
    EBinOp :: Expr -> Op -> Expr -> Tree Expr_
    LVar :: Ident -> Tree LVal_
    LArrAcc :: Expr -> Expr -> Tree LVal_
    LClsAcc :: Expr -> Ident -> Tree LVal_
    LTClsAcc :: Type -> Expr -> Ident -> Tree LVal_
    Plus :: Tree Op_
    Minus :: Tree Op_
    Times :: Tree Op_
    Div :: Tree Op_
    Mod :: Tree Op_
    LTH :: Tree Op_
    LE :: Tree Op_
    GTH :: Tree Op_
    GE :: Tree Op_
    EQU :: Tree Op_
    NE :: Tree Op_
    AND :: Tree Op_
    OR :: Tree Op_
    EQU_Int :: Tree Op_
    EQU_Str :: Tree Op_
    EQU_Arr :: Tree Op_
    EQU_Ref :: Tree Op_
    EQU_Bool :: Tree Op_
    NE_Int :: Tree Op_
    NE_Str :: Tree Op_
    NE_Arr :: Tree Op_
    NE_Ref :: Tree Op_
    NE_Bool :: Tree Op_
    Plus_Int :: Tree Op_
    Plus_Str :: Tree Op_
    Ident :: String -> Tree Ident_

instance Compos Tree where
  compos r a f t = case t of
      Program topdefs -> r Program `a` foldr (a . a (r (:)) . f) (r []) topdefs
      FnTopDef fndef -> r FnTopDef `a` f fndef
      ClsTopDef clsdef -> r ClsTopDef `a` f clsdef
      MetDef fndef -> r MetDef `a` f fndef
      FieldDef type' fditems -> r FieldDef `a` f type' `a` foldr (a . a (r (:)) . f) (r []) fditems
      FdNoInit ident -> r FdNoInit `a` f ident
      Arg type' ident -> r Arg `a` f type' `a` f ident
      FnDef type' ident args block -> r FnDef `a` f type' `a` f ident `a` foldr (a . a (r (:)) . f) (r []) args `a` f block
      ClsDef ident memberdefs -> r ClsDef `a` f ident `a` foldr (a . a (r (:)) . f) (r []) memberdefs
      ClsDefEx ident0 ident1 memberdefs2 -> r ClsDefEx `a` f ident0 `a` f ident1 `a` foldr (a . a (r (:)) . f) (r []) memberdefs2
      Block stmts -> r Block `a` foldr (a . a (r (:)) . f) (r []) stmts
      BStmt block -> r BStmt `a` f block
      Decl type' items -> r Decl `a` f type' `a` foldr (a . a (r (:)) . f) (r []) items
      Ass lval expr -> r Ass `a` f lval `a` f expr
      Incr lval -> r Incr `a` f lval
      Decr lval -> r Decr `a` f lval
      Ret expr -> r Ret `a` f expr
      Cond expr stmt -> r Cond `a` f expr `a` f stmt
      CondElse expr stmt0 stmt1 -> r CondElse `a` f expr `a` f stmt0 `a` f stmt1
      While expr stmt -> r While `a` f expr `a` f stmt
      For type' ident expr stmt -> r For `a` f type' `a` f ident `a` f expr `a` f stmt
      SExp expr -> r SExp `a` f expr
      NoInit ident -> r NoInit `a` f ident
      Init ident expr -> r Init `a` f ident `a` f expr
      ClassT ident -> r ClassT `a` f ident
      ArrayT type' -> r ArrayT `a` f type'
      FunT type' types -> r FunT `a` f type' `a` foldr (a . a (r (:)) . f) (r []) types
      ELitNull type' -> r ELitNull `a` f type'
      EApp ident exprs -> r EApp `a` f ident `a` foldr (a . a (r (:)) . f) (r []) exprs
      ClsApply expr ident exprs -> r ClsApply `a` f expr `a` f ident `a` foldr (a . a (r (:)) . f) (r []) exprs
      TClsApply type' expr ident exprs -> r TClsApply `a` f type' `a` f expr `a` f ident `a` foldr (a . a (r (:)) . f) (r []) exprs
      ELVal lval -> r ELVal `a` f lval
      ArrAlloc type' expr -> r ArrAlloc `a` f type' `a` f expr
      ClsAlloc ident -> r ClsAlloc `a` f ident
      Neg expr -> r Neg `a` f expr
      Not expr -> r Not `a` f expr
      EMul expr0 op1 expr2 -> r EMul `a` f expr0 `a` f op1 `a` f expr2
      EAdd expr0 op1 expr2 -> r EAdd `a` f expr0 `a` f op1 `a` f expr2
      ERel expr0 op1 expr2 -> r ERel `a` f expr0 `a` f op1 `a` f expr2
      EAnd expr0 op1 expr2 -> r EAnd `a` f expr0 `a` f op1 `a` f expr2
      EOr expr0 op1 expr2 -> r EOr `a` f expr0 `a` f op1 `a` f expr2
      EBinOp expr0 op1 expr2 -> r EBinOp `a` f expr0 `a` f op1 `a` f expr2
      LVar ident -> r LVar `a` f ident
      LArrAcc expr0 expr1 -> r LArrAcc `a` f expr0 `a` f expr1
      LClsAcc expr ident -> r LClsAcc `a` f expr `a` f ident
      LTClsAcc type' expr ident -> r LTClsAcc `a` f type' `a` f expr `a` f ident
      _ -> r t

instance Show (Tree c) where
  showsPrec n t = case t of
    Program topdefs -> opar n . showString "Program" . showChar ' ' . showsPrec 1 topdefs . cpar n
    FnTopDef fndef -> opar n . showString "FnTopDef" . showChar ' ' . showsPrec 1 fndef . cpar n
    ClsTopDef clsdef -> opar n . showString "ClsTopDef" . showChar ' ' . showsPrec 1 clsdef . cpar n
    MetDef fndef -> opar n . showString "MetDef" . showChar ' ' . showsPrec 1 fndef . cpar n
    FieldDef type' fditems -> opar n . showString "FieldDef" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 fditems . cpar n
    FdNoInit ident -> opar n . showString "FdNoInit" . showChar ' ' . showsPrec 1 ident . cpar n
    Arg type' ident -> opar n . showString "Arg" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 ident . cpar n
    FnDef type' ident args block -> opar n . showString "FnDef" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 args . showChar ' ' . showsPrec 1 block . cpar n
    ClsDef ident memberdefs -> opar n . showString "ClsDef" . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 memberdefs . cpar n
    ClsDefEx ident0 ident1 memberdefs2 -> opar n . showString "ClsDefEx" . showChar ' ' . showsPrec 1 ident0 . showChar ' ' . showsPrec 1 ident1 . showChar ' ' . showsPrec 1 memberdefs2 . cpar n
    Block stmts -> opar n . showString "Block" . showChar ' ' . showsPrec 1 stmts . cpar n
    Empty -> showString "Empty"
    BStmt block -> opar n . showString "BStmt" . showChar ' ' . showsPrec 1 block . cpar n
    Decl type' items -> opar n . showString "Decl" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 items . cpar n
    Ass lval expr -> opar n . showString "Ass" . showChar ' ' . showsPrec 1 lval . showChar ' ' . showsPrec 1 expr . cpar n
    Incr lval -> opar n . showString "Incr" . showChar ' ' . showsPrec 1 lval . cpar n
    Decr lval -> opar n . showString "Decr" . showChar ' ' . showsPrec 1 lval . cpar n
    Ret expr -> opar n . showString "Ret" . showChar ' ' . showsPrec 1 expr . cpar n
    VRet -> showString "VRet"
    Cond expr stmt -> opar n . showString "Cond" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt . cpar n
    CondElse expr stmt0 stmt1 -> opar n . showString "CondElse" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt0 . showChar ' ' . showsPrec 1 stmt1 . cpar n
    While expr stmt -> opar n . showString "While" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt . cpar n
    For type' ident expr stmt -> opar n . showString "For" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt . cpar n
    SExp expr -> opar n . showString "SExp" . showChar ' ' . showsPrec 1 expr . cpar n
    NoInit ident -> opar n . showString "NoInit" . showChar ' ' . showsPrec 1 ident . cpar n
    Init ident expr -> opar n . showString "Init" . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 expr . cpar n
    IntT -> showString "IntT"
    StringT -> showString "StringT"
    BooleanT -> showString "BooleanT"
    VoidT -> showString "VoidT"
    ClassT ident -> opar n . showString "ClassT" . showChar ' ' . showsPrec 1 ident . cpar n
    ArrayT type' -> opar n . showString "ArrayT" . showChar ' ' . showsPrec 1 type' . cpar n
    FunT type' types -> opar n . showString "FunT" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 types . cpar n
    ELitInt integer -> opar n . showString "ELitInt" . showChar ' ' . showsPrec 1 integer . cpar n
    ELitTrue -> showString "ELitTrue"
    ELitFalse -> showString "ELitFalse"
    ELitNull type' -> opar n . showString "ELitNull" . showChar ' ' . showsPrec 1 type' . cpar n
    EString string -> opar n . showString "EString" . showChar ' ' . showsPrec 1 string . cpar n
    EApp ident exprs -> opar n . showString "EApp" . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 exprs . cpar n
    ClsApply expr ident exprs -> opar n . showString "ClsApply" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 exprs . cpar n
    TClsApply type' expr ident exprs -> opar n . showString "TClsApply" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 exprs . cpar n
    ELVal lval -> opar n . showString "ELVal" . showChar ' ' . showsPrec 1 lval . cpar n
    ArrAlloc type' expr -> opar n . showString "ArrAlloc" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 expr . cpar n
    ClsAlloc ident -> opar n . showString "ClsAlloc" . showChar ' ' . showsPrec 1 ident . cpar n
    Neg expr -> opar n . showString "Neg" . showChar ' ' . showsPrec 1 expr . cpar n
    Not expr -> opar n . showString "Not" . showChar ' ' . showsPrec 1 expr . cpar n
    EMul expr0 op1 expr2 -> opar n . showString "EMul" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EAdd expr0 op1 expr2 -> opar n . showString "EAdd" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    ERel expr0 op1 expr2 -> opar n . showString "ERel" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EAnd expr0 op1 expr2 -> opar n . showString "EAnd" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EOr expr0 op1 expr2 -> opar n . showString "EOr" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EBinOp expr0 op1 expr2 -> opar n . showString "EBinOp" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 op1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    LVar ident -> opar n . showString "LVar" . showChar ' ' . showsPrec 1 ident . cpar n
    LArrAcc expr0 expr1 -> opar n . showString "LArrAcc" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 expr1 . cpar n
    LClsAcc expr ident -> opar n . showString "LClsAcc" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 ident . cpar n
    LTClsAcc type' expr ident -> opar n . showString "LTClsAcc" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 ident . cpar n
    Plus -> showString "Plus"
    Minus -> showString "Minus"
    Times -> showString "Times"
    Div -> showString "Div"
    Mod -> showString "Mod"
    LTH -> showString "LTH"
    LE -> showString "LE"
    GTH -> showString "GTH"
    GE -> showString "GE"
    EQU -> showString "EQU"
    NE -> showString "NE"
    AND -> showString "AND"
    OR -> showString "OR"
    EQU_Int -> showString "EQU_Int"
    EQU_Str -> showString "EQU_Str"
    EQU_Arr -> showString "EQU_Arr"
    EQU_Ref -> showString "EQU_Ref"
    EQU_Bool -> showString "EQU_Bool"
    NE_Int -> showString "NE_Int"
    NE_Str -> showString "NE_Str"
    NE_Arr -> showString "NE_Arr"
    NE_Ref -> showString "NE_Ref"
    NE_Bool -> showString "NE_Bool"
    Plus_Int -> showString "Plus_Int"
    Plus_Str -> showString "Plus_Str"
    Ident str -> opar n . showString "Ident" . showChar ' ' . showsPrec 1 str . cpar n
   where opar n = if n > 0 then showChar '(' else id
         cpar n = if n > 0 then showChar ')' else id

instance Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> Bool
johnMajorEq (Program topdefs) (Program topdefs_) = topdefs == topdefs_
johnMajorEq (FnTopDef fndef) (FnTopDef fndef_) = fndef == fndef_
johnMajorEq (ClsTopDef clsdef) (ClsTopDef clsdef_) = clsdef == clsdef_
johnMajorEq (MetDef fndef) (MetDef fndef_) = fndef == fndef_
johnMajorEq (FieldDef type' fditems) (FieldDef type'_ fditems_) = type' == type'_ && fditems == fditems_
johnMajorEq (FdNoInit ident) (FdNoInit ident_) = ident == ident_
johnMajorEq (Arg type' ident) (Arg type'_ ident_) = type' == type'_ && ident == ident_
johnMajorEq (FnDef type' ident args block) (FnDef type'_ ident_ args_ block_) = type' == type'_ && ident == ident_ && args == args_ && block == block_
johnMajorEq (ClsDef ident memberdefs) (ClsDef ident_ memberdefs_) = ident == ident_ && memberdefs == memberdefs_
johnMajorEq (ClsDefEx ident0 ident1 memberdefs2) (ClsDefEx ident0_ ident1_ memberdefs2_) = ident0 == ident0_ && ident1 == ident1_ && memberdefs2 == memberdefs2_
johnMajorEq (Block stmts) (Block stmts_) = stmts == stmts_
johnMajorEq Empty Empty = True
johnMajorEq (BStmt block) (BStmt block_) = block == block_
johnMajorEq (Decl type' items) (Decl type'_ items_) = type' == type'_ && items == items_
johnMajorEq (Ass lval expr) (Ass lval_ expr_) = lval == lval_ && expr == expr_
johnMajorEq (Incr lval) (Incr lval_) = lval == lval_
johnMajorEq (Decr lval) (Decr lval_) = lval == lval_
johnMajorEq (Ret expr) (Ret expr_) = expr == expr_
johnMajorEq VRet VRet = True
johnMajorEq (Cond expr stmt) (Cond expr_ stmt_) = expr == expr_ && stmt == stmt_
johnMajorEq (CondElse expr stmt0 stmt1) (CondElse expr_ stmt0_ stmt1_) = expr == expr_ && stmt0 == stmt0_ && stmt1 == stmt1_
johnMajorEq (While expr stmt) (While expr_ stmt_) = expr == expr_ && stmt == stmt_
johnMajorEq (For type' ident expr stmt) (For type'_ ident_ expr_ stmt_) = type' == type'_ && ident == ident_ && expr == expr_ && stmt == stmt_
johnMajorEq (SExp expr) (SExp expr_) = expr == expr_
johnMajorEq (NoInit ident) (NoInit ident_) = ident == ident_
johnMajorEq (Init ident expr) (Init ident_ expr_) = ident == ident_ && expr == expr_
johnMajorEq IntT IntT = True
johnMajorEq StringT StringT = True
johnMajorEq BooleanT BooleanT = True
johnMajorEq VoidT VoidT = True
johnMajorEq (ClassT ident) (ClassT ident_) = ident == ident_
johnMajorEq (ArrayT type') (ArrayT type'_) = type' == type'_
johnMajorEq (FunT type' types) (FunT type'_ types_) = type' == type'_ && types == types_
johnMajorEq (ELitInt integer) (ELitInt integer_) = integer == integer_
johnMajorEq ELitTrue ELitTrue = True
johnMajorEq ELitFalse ELitFalse = True
johnMajorEq (ELitNull type') (ELitNull type'_) = type' == type'_
johnMajorEq (EString string) (EString string_) = string == string_
johnMajorEq (EApp ident exprs) (EApp ident_ exprs_) = ident == ident_ && exprs == exprs_
johnMajorEq (ClsApply expr ident exprs) (ClsApply expr_ ident_ exprs_) = expr == expr_ && ident == ident_ && exprs == exprs_
johnMajorEq (TClsApply type' expr ident exprs) (TClsApply type'_ expr_ ident_ exprs_) = type' == type'_ && expr == expr_ && ident == ident_ && exprs == exprs_
johnMajorEq (ELVal lval) (ELVal lval_) = lval == lval_
johnMajorEq (ArrAlloc type' expr) (ArrAlloc type'_ expr_) = type' == type'_ && expr == expr_
johnMajorEq (ClsAlloc ident) (ClsAlloc ident_) = ident == ident_
johnMajorEq (Neg expr) (Neg expr_) = expr == expr_
johnMajorEq (Not expr) (Not expr_) = expr == expr_
johnMajorEq (EMul expr0 op1 expr2) (EMul expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (EAdd expr0 op1 expr2) (EAdd expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (ERel expr0 op1 expr2) (ERel expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (EAnd expr0 op1 expr2) (EAnd expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (EOr expr0 op1 expr2) (EOr expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (EBinOp expr0 op1 expr2) (EBinOp expr0_ op1_ expr2_) = expr0 == expr0_ && op1 == op1_ && expr2 == expr2_
johnMajorEq (LVar ident) (LVar ident_) = ident == ident_
johnMajorEq (LArrAcc expr0 expr1) (LArrAcc expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq (LClsAcc expr ident) (LClsAcc expr_ ident_) = expr == expr_ && ident == ident_
johnMajorEq (LTClsAcc type' expr ident) (LTClsAcc type'_ expr_ ident_) = type' == type'_ && expr == expr_ && ident == ident_
johnMajorEq Plus Plus = True
johnMajorEq Minus Minus = True
johnMajorEq Times Times = True
johnMajorEq Div Div = True
johnMajorEq Mod Mod = True
johnMajorEq LTH LTH = True
johnMajorEq LE LE = True
johnMajorEq GTH GTH = True
johnMajorEq GE GE = True
johnMajorEq EQU EQU = True
johnMajorEq NE NE = True
johnMajorEq AND AND = True
johnMajorEq OR OR = True
johnMajorEq EQU_Int EQU_Int = True
johnMajorEq EQU_Str EQU_Str = True
johnMajorEq EQU_Arr EQU_Arr = True
johnMajorEq EQU_Ref EQU_Ref = True
johnMajorEq EQU_Bool EQU_Bool = True
johnMajorEq NE_Int NE_Int = True
johnMajorEq NE_Str NE_Str = True
johnMajorEq NE_Arr NE_Arr = True
johnMajorEq NE_Ref NE_Ref = True
johnMajorEq NE_Bool NE_Bool = True
johnMajorEq Plus_Int Plus_Int = True
johnMajorEq Plus_Str Plus_Str = True
johnMajorEq (Ident str) (Ident str_) = str == str_
johnMajorEq _ _ = False

instance Ord (Tree c) where
  compare x y = compare (index x) (index y) `mappend` compareSame x y
index :: Tree c -> Int
index (Program _) = 0
index (FnTopDef _) = 1
index (ClsTopDef _) = 2
index (MetDef _) = 3
index (FieldDef _ _) = 4
index (FdNoInit _) = 5
index (Arg _ _) = 6
index (FnDef _ _ _ _) = 7
index (ClsDef _ _) = 8
index (ClsDefEx _ _ _) = 9
index (Block _) = 10
index (Empty ) = 11
index (BStmt _) = 12
index (Decl _ _) = 13
index (Ass _ _) = 14
index (Incr _) = 15
index (Decr _) = 16
index (Ret _) = 17
index (VRet ) = 18
index (Cond _ _) = 19
index (CondElse _ _ _) = 20
index (While _ _) = 21
index (For _ _ _ _) = 22
index (SExp _) = 23
index (NoInit _) = 24
index (Init _ _) = 25
index (IntT ) = 26
index (StringT ) = 27
index (BooleanT ) = 28
index (VoidT ) = 29
index (ClassT _) = 30
index (ArrayT _) = 31
index (FunT _ _) = 32
index (ELitInt _) = 33
index (ELitTrue ) = 34
index (ELitFalse ) = 35
index (ELitNull _) = 36
index (EString _) = 37
index (EApp _ _) = 38
index (ClsApply _ _ _) = 39
index (TClsApply _ _ _ _) = 40
index (ELVal _) = 41
index (ArrAlloc _ _) = 42
index (ClsAlloc _) = 43
index (Neg _) = 44
index (Not _) = 45
index (EMul _ _ _) = 46
index (EAdd _ _ _) = 47
index (ERel _ _ _) = 48
index (EAnd _ _ _) = 49
index (EOr _ _ _) = 50
index (EBinOp _ _ _) = 51
index (LVar _) = 52
index (LArrAcc _ _) = 53
index (LClsAcc _ _) = 54
index (LTClsAcc _ _ _) = 55
index (Plus ) = 56
index (Minus ) = 57
index (Times ) = 58
index (Div ) = 59
index (Mod ) = 60
index (LTH ) = 61
index (LE ) = 62
index (GTH ) = 63
index (GE ) = 64
index (EQU ) = 65
index (NE ) = 66
index (AND ) = 67
index (OR ) = 68
index (EQU_Int ) = 69
index (EQU_Str ) = 70
index (EQU_Arr ) = 71
index (EQU_Ref ) = 72
index (EQU_Bool ) = 73
index (NE_Int ) = 74
index (NE_Str ) = 75
index (NE_Arr ) = 76
index (NE_Ref ) = 77
index (NE_Bool ) = 78
index (Plus_Int ) = 79
index (Plus_Str ) = 80
index (Ident _) = 81
compareSame :: Tree c -> Tree c -> Ordering
compareSame (Program topdefs) (Program topdefs_) = compare topdefs topdefs_
compareSame (FnTopDef fndef) (FnTopDef fndef_) = compare fndef fndef_
compareSame (ClsTopDef clsdef) (ClsTopDef clsdef_) = compare clsdef clsdef_
compareSame (MetDef fndef) (MetDef fndef_) = compare fndef fndef_
compareSame (FieldDef type' fditems) (FieldDef type'_ fditems_) = mappend (compare type' type'_) (compare fditems fditems_)
compareSame (FdNoInit ident) (FdNoInit ident_) = compare ident ident_
compareSame (Arg type' ident) (Arg type'_ ident_) = mappend (compare type' type'_) (compare ident ident_)
compareSame (FnDef type' ident args block) (FnDef type'_ ident_ args_ block_) = mappend (compare type' type'_) (mappend (compare ident ident_) (mappend (compare args args_) (compare block block_)))
compareSame (ClsDef ident memberdefs) (ClsDef ident_ memberdefs_) = mappend (compare ident ident_) (compare memberdefs memberdefs_)
compareSame (ClsDefEx ident0 ident1 memberdefs2) (ClsDefEx ident0_ ident1_ memberdefs2_) = mappend (compare ident0 ident0_) (mappend (compare ident1 ident1_) (compare memberdefs2 memberdefs2_))
compareSame (Block stmts) (Block stmts_) = compare stmts stmts_
compareSame Empty Empty = EQ
compareSame (BStmt block) (BStmt block_) = compare block block_
compareSame (Decl type' items) (Decl type'_ items_) = mappend (compare type' type'_) (compare items items_)
compareSame (Ass lval expr) (Ass lval_ expr_) = mappend (compare lval lval_) (compare expr expr_)
compareSame (Incr lval) (Incr lval_) = compare lval lval_
compareSame (Decr lval) (Decr lval_) = compare lval lval_
compareSame (Ret expr) (Ret expr_) = compare expr expr_
compareSame VRet VRet = EQ
compareSame (Cond expr stmt) (Cond expr_ stmt_) = mappend (compare expr expr_) (compare stmt stmt_)
compareSame (CondElse expr stmt0 stmt1) (CondElse expr_ stmt0_ stmt1_) = mappend (compare expr expr_) (mappend (compare stmt0 stmt0_) (compare stmt1 stmt1_))
compareSame (While expr stmt) (While expr_ stmt_) = mappend (compare expr expr_) (compare stmt stmt_)
compareSame (For type' ident expr stmt) (For type'_ ident_ expr_ stmt_) = mappend (compare type' type'_) (mappend (compare ident ident_) (mappend (compare expr expr_) (compare stmt stmt_)))
compareSame (SExp expr) (SExp expr_) = compare expr expr_
compareSame (NoInit ident) (NoInit ident_) = compare ident ident_
compareSame (Init ident expr) (Init ident_ expr_) = mappend (compare ident ident_) (compare expr expr_)
compareSame IntT IntT = EQ
compareSame StringT StringT = EQ
compareSame BooleanT BooleanT = EQ
compareSame VoidT VoidT = EQ
compareSame (ClassT ident) (ClassT ident_) = compare ident ident_
compareSame (ArrayT type') (ArrayT type'_) = compare type' type'_
compareSame (FunT type' types) (FunT type'_ types_) = mappend (compare type' type'_) (compare types types_)
compareSame (ELitInt integer) (ELitInt integer_) = compare integer integer_
compareSame ELitTrue ELitTrue = EQ
compareSame ELitFalse ELitFalse = EQ
compareSame (ELitNull type') (ELitNull type'_) = compare type' type'_
compareSame (EString string) (EString string_) = compare string string_
compareSame (EApp ident exprs) (EApp ident_ exprs_) = mappend (compare ident ident_) (compare exprs exprs_)
compareSame (ClsApply expr ident exprs) (ClsApply expr_ ident_ exprs_) = mappend (compare expr expr_) (mappend (compare ident ident_) (compare exprs exprs_))
compareSame (TClsApply type' expr ident exprs) (TClsApply type'_ expr_ ident_ exprs_) = mappend (compare type' type'_) (mappend (compare expr expr_) (mappend (compare ident ident_) (compare exprs exprs_)))
compareSame (ELVal lval) (ELVal lval_) = compare lval lval_
compareSame (ArrAlloc type' expr) (ArrAlloc type'_ expr_) = mappend (compare type' type'_) (compare expr expr_)
compareSame (ClsAlloc ident) (ClsAlloc ident_) = compare ident ident_
compareSame (Neg expr) (Neg expr_) = compare expr expr_
compareSame (Not expr) (Not expr_) = compare expr expr_
compareSame (EMul expr0 op1 expr2) (EMul expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (EAdd expr0 op1 expr2) (EAdd expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (ERel expr0 op1 expr2) (ERel expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (EAnd expr0 op1 expr2) (EAnd expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (EOr expr0 op1 expr2) (EOr expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (EBinOp expr0 op1 expr2) (EBinOp expr0_ op1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare op1 op1_) (compare expr2 expr2_))
compareSame (LVar ident) (LVar ident_) = compare ident ident_
compareSame (LArrAcc expr0 expr1) (LArrAcc expr0_ expr1_) = mappend (compare expr0 expr0_) (compare expr1 expr1_)
compareSame (LClsAcc expr ident) (LClsAcc expr_ ident_) = mappend (compare expr expr_) (compare ident ident_)
compareSame (LTClsAcc type' expr ident) (LTClsAcc type'_ expr_ ident_) = mappend (compare type' type'_) (mappend (compare expr expr_) (compare ident ident_))
compareSame Plus Plus = EQ
compareSame Minus Minus = EQ
compareSame Times Times = EQ
compareSame Div Div = EQ
compareSame Mod Mod = EQ
compareSame LTH LTH = EQ
compareSame LE LE = EQ
compareSame GTH GTH = EQ
compareSame GE GE = EQ
compareSame EQU EQU = EQ
compareSame NE NE = EQ
compareSame AND AND = EQ
compareSame OR OR = EQ
compareSame EQU_Int EQU_Int = EQ
compareSame EQU_Str EQU_Str = EQ
compareSame EQU_Arr EQU_Arr = EQ
compareSame EQU_Ref EQU_Ref = EQ
compareSame EQU_Bool EQU_Bool = EQ
compareSame NE_Int NE_Int = EQ
compareSame NE_Str NE_Str = EQ
compareSame NE_Arr NE_Arr = EQ
compareSame NE_Ref NE_Ref = EQ
compareSame NE_Bool NE_Bool = EQ
compareSame Plus_Int Plus_Int = EQ
compareSame Plus_Str Plus_Str = EQ
compareSame (Ident str) (Ident str_) = compare str str_
compareSame x y = error "BNFC error:" compareSame
